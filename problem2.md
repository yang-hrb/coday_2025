这是一份根据提供的 PDF (`TaskTwo-HarmonizedCrystals.pdf`) 和测试文件整理的 Markdown 格式题目要求。

***

# Task Two: Harmonized Crystals

## 背景描述

Master Artificer Elomar 正在教导他的学徒（你）如何评估“魔法源（Magic Source）”的力量。魔法源由生长在洞穴中的“和谐水晶（Harmonized Crystals）”阵列组成。

为了最大化魔法源的力量，你需要从原始的水晶阵列中**移除**一些破坏和谐的水晶（不能改变剩余水晶的顺序），从而留下一个最长的“和谐组（Harmonized Group）”。

魔法源的真正力量等于这个**最长和谐组的长度**。

## 题目要求 (Harmonized Group Definition)

一个“和谐组”是一个满足以下条件的水晶子序列（Subsequence）：

1. **结构组成**：它由 **3 部分** 组成，按顺序排列。
2. **单一类型**：每一部分内部只能包含**同一种类型**的水晶。
    * 例如：Part 1 全是类型 A，Part 2 全是类型 B，Part 3 全是类型 C。
3. **类型限制**：整个和谐组中，**最多只能包含两种不同类型**的水晶。
    * 这意味着 Part 1 和 Part 3 的类型必须相同（设为类型 A）。
    * Part 2 的类型可以是 A，也可以是另一种类型 B。
4. **对称性（Symmetry）**：Part 1 和 Part 3 必须包含**相同数量**的水晶。
    * 设 Part 1 长度为 $K$，则 Part 3 长度也必须为 $K$。
    * Part 2 的长度 $M$ 可以是任意非负整数（$M \ge 0$）。
5. **总结形式**：
    * 序列形式为：$\underbrace{A, A, \dots, A}_{K} + \underbrace{B, B, \dots, B}_{M} + \underbrace{A, A, \dots, A}_{K}$
    * 其中 $K \ge 0, M \ge 0$。
    * $A$ 和 $B$ 是水晶的 ID。

**目标**：给定一个水晶阵列，找到可以通过移除元素（保持相对顺序）得到的**最长**和谐组的长度（即 $2K + M$ 的最大值）。

## 输入格式 (Input Format)

输入的第一行包含一个整数，表示测试用例（Crystalline Arrays）的数量。
对于每一个测试用例：

1. 第一行：一个整数 $N$，表示该阵列中水晶的总数。
2. 第二行：$N$ 个整数，表示水晶的 ID（Type）。

## 输出格式 (Output Format)

* 对于每个测试用例，输出一个整数，表示最长和谐组的长度。
* *(注：根据 Python 测试脚本，输出通常是一个包含所有结果的列表，但在算法实现中通常逐行输出或按要求返回集合)*


## 数据范围 (Constraints)

* **水晶阵列数量**: $1 \le T \le 10$ (根据 PDF 示例推断)
* **数组长度 ($N$)**: $1 \le N \le 200,000$
* **所有数组长度之和**: $\le 200,000$
* **水晶 ID 范围**: $1 \le \text{ID} \le 200$


## Test Cases

以下测试用例来源于附件中的文本文件及 Python 测试脚本 (`test_task_two.py`)。

### Test Case 0 (from `Test0.txt`)

**Input:**

```text
2
10
1 1 12 1 22 33 13 22 1 1
5
1 1 1 1 1
```

**Expected Output:**

```text
[6, 5]
```

*解释 (Case 1):*
原始序列：`1, 1, 12, 1, 22, 33, 13, 22, 1, 1`
最佳子序列：`1, 1` (indices 0,1) + `22, 22` (indices 4,7) + `1, 1` (indices 8,9)。
结构：$K=2$ (Type 1), $M=2$ (Type 22), $K=2$ (Type 1)。总长度 $2+2+2 = 6$。

*解释 (Case 2):*
原始序列：`1, 1, 1, 1, 1`
最佳子序列：全选。$K=0, M=5$ (Type 1) 或 $K=2, M=1, K=2$。总长度 5。

***

### Test Case 1 (from `Test1.txt`)

**Input:**

```text
4
6
90 100 90 100 36 100
6
37 46 68 13 46 46
6
177 55 177 177 55 55
6
92 86 86 97 97 97
```

**Expected Output:**

```text
[3, 3, 4, 3]
```

*解释 (Case 3):*
原始：`177, 55, 177, 177, 55, 55`
最佳：`55` (index 1) + `177, 177` (indices 2,3) + `55` (index 4 或 5)。
结构：$K=1$ (Type 55) + $M=2$ (Type 177) + $K=1$ (Type 55)。总长度 4。

***

### Test Case 2 (from `Test2.txt`)

**Input:**

```text
5
10
80 47 28 87 99 76 47 80 80 80
10
36 162 107 11 70 70 36 109 70 162
10
197 28 32 121 197 32 32 121 197 32
10
61 61 185 61 181 181 80 31 80 80
10
146 179 149 93 145 93 93 145 123 93
```

**Expected Output:**

```text
[4, 5, 5, 3, 4]
```


***

### Test Case 3 (from `Test3.txt`)

**Input:**

```text
8
5
4 3 5 3 5
5
3 4 2 3 4
6
1 3 3 1 1 4
6
1 1 2 5 6 6
6
1 2 2 5 6 3
6
1 2 1 5 1 4
5
3 3 2 2 3
5
1 1 3 1 5
```

**Expected Output:**

```text
[3, 3, 4, 2, 2, 3, 4, 3]
```

