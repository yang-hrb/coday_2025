这是一份根据提供的 PDF (`TaskThree-TheLongestStory.pdf`) 和测试文件整理的 Markdown 格式题目要求。

***

# Task Three: The Longest Story of NiCE Realm

## 背景描述

Keytara 是一名在 NiCE 王国图书馆长大的书迷，她的母亲是图书馆馆长。为了继承母亲成为知识的守护者，她必须回答一个问题：**“最长故事（The Longest Story）”的数字是多少**？

Keytara 创建了一个包含所有书本之间引用关系的目录（Catalogue）。她决定用**引用中的字数（number of letters/words）**作为书本之间连接强度的度量。

为了找到“最长故事”，她制定了两条规则来筛选引用链：

1. **Rule of Ever-growing Connection (连接不断增强规则)**: 故事中的每一个后续引用必须比前一个引用**更强**（即字数更多）。如果是相同强度，则不算“更强”。
2. **Rule of Only Forward (只能前进规则)**: 故事中的引用必须按照目录中的顺序“向前”移动。也就是说，如果当前引用的书在目录中的索引是 $i$，下一个引用的书在目录中的索引必须是 $j > i$。（*注意：虽然 PDF 这里的描述比较隐晦，提到 "move back in my catalogue"，但结合示例和算法常规，这里的 Forward 通常指引用在输入列表中的出现顺序，或者更可能指引用的源书和目标书的某种顺序。**仔细阅读 Example 和 Test Cases 后发现**：题目中的 "catalogue" 实际上就是给出的引用列表。规则含义是：你必须从这个列表中选出一个**子序列（Subsequence）**，保持它们在列表中的原始相对顺序。*）

**修正理解**：
题目本质上是在一个给定的引用序列中，寻找一个**最长的子序列**，使得该子序列满足：

1. **连接性**：前一个引用的“目标书（Book which is referenced）”必须是后一个引用的“源书（Book with reference）”。
2. **递增性**：后一个引用的“强度（字数）”必须**严格大于**前一个引用的强度。
3. **顺序性**：子序列中的引用必须按照它们在输入中出现的顺序排列（即 $Index_{k} < Index_{k+1}$）。

*再次校对 PDF 描述与 Example*：
PDF 中提到 "Rule of Only Forward" 时说 "I shouldn't move back in my catalogue as well"。
Example:
Input:

```
6 5 (6本书, 5个引用)
1 2 1 (书1 引用 书2, 强度1)
2 3 2 (书2 引用 书3, 强度2)
3 4 3 (书3 引用 书4, 强度3)
5 4 10 (书5 引用 书4, 强度10)
4 6 11 (书4 引用 书6, 强度11)
```

Output: 4
解释：最长链是 `1->2 (1)` -> `2->3 (2)` -> `3->4 (3)` -> `4->6 (11)`。长度为 4。
注意 `5->4 (10)` 虽然强度大，但无法接在 `3->4` 后面（因为 `3->4` 的结尾是 4，而 `5->4` 的开头是 5），也无法接在 `4->6` 前面（虽然 4 匹配，但 `5->4` 在输入列表中排在 `4->6` 前面？不对，输入是按顺序给的）。

**核心逻辑推导**：
这实际上是一个变体的**最长递增子序列 (LIS)** 或 **最长路径** 问题。
给定一个有向图的边列表（按输入顺序排列），你需要从中选出一个边的子序列 $E_1, E_2, \dots, E_k$，满足：

1. **输入顺序**：$E_1$ 在输入中的位置 $< E_2$ 在输入中的位置 $< \dots$
2. **首尾相连**：$E_i$ 的目标节点 $v == E_{i+1}$ 的源节点 $u$。
3. **权重递增**：$E_i$ 的权重 $< E_{i+1}$ 的权重。

## 题目要求

给定 $N$ 本书和 $M$ 个引用关系。每个引用关系由 $(u, v, w)$ 组成，表示书 $u$ 引用了书 $v$，强度为 $w$。
请找到一个最长的引用序列（References 数量最大），使得序列中的每个引用 $(u_i, v_i, w_i)$ 和下一个引用 $(u_{i+1}, v_{i+1}, w_{i+1})$ 满足：

1. 该序列是原输入序列的子序列（保持相对顺序）。
2. $v_i = u_{i+1}$ （书本衔接）。
3. $w_i < w_{i+1}$ （强度严格递增）。

## 输入格式 (Input Format)

第一行包含两个整数 $N$ 和 $M$。

* $N$：书的数量 (Number of books)。
* $M$：引用的数量 (Number of references)。

接下来的 $M$ 行，每行包含三个整数 $u, v, w$：

* $u$：发出引用的书的 ID (1..N)。
* $v$：被引用的书的 ID (1..N)。
* $w$：引用的强度/字数 (Number of words)。


## 输出格式 (Output Format)

* 输出一个整数，表示满足条件的最长引用链的长度（包含的引用数量）。


## 数据范围 (Constraints)

* **书的数量 ($N$)**: $1 \le N \le 100,000$
* **引用数量 ($M$)**: $1 \le M \le 100,000$
* **引用强度 ($w$)**: $0 \le w \le 100,000$
* **书的 ID**: $1 \le ID \le N$


## Test Cases

以下测试用例来源于附件中的文本文件及 Python 测试脚本 (`test_task_three.py`)。

### Test Case 0 (from `Test0.txt` \& PDF Example)

**Input:**

```text
6 5
1 2 1
2 3 2
3 4 3
5 4 10
4 6 11
```

**Expected Output:**

```text
4
```

*解释：*
最长链：

1. `1 2 1` (u=1, v=2, w=1)
2. `2 3 2` (u=2, v=3, w=2, 匹配前一个 v=2, w>1)
3. `3 4 3` (u=3, v=4, w=3, 匹配前一个 v=3, w>2)
4. `4 6 11` (u=4, v=6, w=11, 匹配前一个 v=4, w>3)
长度为 4。
注意：`5 4 10` 无法插入，因为它不满足首尾相连（需要以 5 结尾的前序，或作为以 4 开头的后继但强度需 >10）。

***

### Test Case 1 (from `Test1.txt`)

**Input:**

```text
5 10
3 4 8366
5 1 6059
2 1 72369
2 2 35472
5 3 50268
2 4 98054
5 1 26220
2 3 24841
1 3 42450
3 1 59590
```

**Expected Output:**

```text
3
```

*解释：*
可能的一条路径：

1. `2 3 24841` (第 8 行)
2. `3 1 59590` (第 10 行，v=3 -> u=3, w=59590 > 24841)
*等等，第 8 行在第 10 行之前，符合顺序。*
另一条可能：
3. `5 1 26220` (第 7 行)
4. `1 3 42450` (第 9 行)
5. `3 1 59590` (第 10 行)
长度为 3。

***

### Test Case 2 (from `Test2.txt`)

**Input:**

```text
5 5
1 3 4
3 2 5
3 4 7
5 4 2
4 5 8
```

**Expected Output:**

```text
3
```

*解释：*
路径：

1. `1 3 4`
2. `3 4 7` (跳过 `3 2 5` 因为它虽连接但不是最优解的一部分，或者此路径更长)
3. `4 5 8`
长度：3。

***

### Test Case 3 (from `Test3.txt`)

**Input:**

```text
3 3
3 1 8
1 2 5
2 3 6
```

**Expected Output:**

```text
2
```

*解释：*
虽然 `3->1->2->3` 看起来像个环，但必须遵循**输入顺序**和**强度递增**。
可能的链：

- `1 2 5` -> `2 3 6` (长度 2)
- `3 1 8` (无法接后续，因为后续的 $w$ 都比 8 小)
最大长度 2。

***

### Test Case 4 (from `Test4.txt`)

**Input:**

```text
1000 10
11 368 48256
192 176 81266
236 360 25346
377 962 3089
486 176 49857
693 810 36660
692 698 35141
879 822 10964
974 439 31998
364 142 62668
```

**Expected Output:**
*这个 Case 在 test_task_three.py 中没有显式的 expected value 检查代码块，但根据逻辑可推断。通常作为大数据量测试或 corner case。*

